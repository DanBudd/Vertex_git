function [VERTEX] = setupSimulation(params, connections, electrodes)

% This function goes through the set up part of runSimulation and Simulate
% from VERTEX proper, to be used in conjunction with simulateMultiregional in the
% JansenRitmeetsVERTEX implementation.
%
% The inputs are the ones generated by initNetwork, and the output is a
% structure to hold all the necessary values generated here.

TP = params.TissueParams;
NP = params.NeuronParams;
CP = params.ConnectionParams;
RS = params.RecordingSettings;
SS = params.SimulationSettings;


% Get the directory to save files to (and create it if necessary)
outputDirectory = RS.saveDir;
if ~strcmpi(outputDirectory(end), '/')
  outputDirectory = [outputDirectory '/'];
end
if exist(outputDirectory, 'dir') ~= 7
  mkdir(outputDirectory);
end
RS.saveDir = outputDirectory;


% If loading spikes from a previous simulation, and spikeLoadDir is not
% specified in params.SimulationSettings, assume that we are loading spikes
% from the output directory
if isfield(SS,'spikeLoad') 
  if SS.spikeLoad
    if ~isfield(SS, 'spikeLoadDir')
      inputDirectory = outputDirectory;
      SS.spikeLoadDir = inputDirectory;
    end
  end
end
SS.stdp = false;
for c = 1:length(CP)
    for cc = 1:length(CP(c).synapseType)
        if strcmp('g_stdp', CP(c).synapseType{cc})
            SS.stdp = true;
        end
    end
end
    

%NP = NeuronParams;
% Calculate passive neuron properties in correct units
NP = calculatePassiveProperties(NP, TP);


% If using pre-calculated spike times with the loadspiketimes neuron model,
% check the stored spike times can be found, then load them and convert
% into units of timeStep
loadedSpikeTimeCell = cell(TP.numGroups, 1);
for iGroup = 1:TP.numGroups
  if strcmpi(NP(iGroup).neuronModel, 'loadspiketimes')
    spkfile = NP(iGroup).spikeTimeFile; % check spikeTimeDir is a field
    if exist(spkfile,'file') ~= 2
      errMsg = ['The specified spike time file for neuron group ' ...
                 num2str(iGroup) ' does not exist.'];
      error('vertex:runSimulation:spikeTimeDirError', errMsg);
    else
      loadedSpikeTimes = load(spkfile);
      fName = fields(loadedSpikeTimes);
      loadedSpikeTimeCell{iGroup} = loadedSpikeTimes.(fName{1});
      for ii = 1:length(loadedSpikeTimeCell{iGroup})
        loadedSpikeTimeCell{iGroup}{ii} = ...
          sort(round(loadedSpikeTimeCell{iGroup}{ii} ./ SS.timeStep));
      end
    end
  end
end

% Setup the neuron ID mapping for routing spikes, saving variables etc.
[NeuronIDMap] = setupNeuronIDMapping(TP, SS);
disp('Ndyn')
% Initialise the neuron models
[NeuronModelArr] = ...
  setupNeuronDynamicVars(TP, NP, SS, NeuronIDMap, loadedSpikeTimeCell);
disp('syndyn')
% Initialise the synapse models
[SynapseModelArr, synMapCell] = setupSynapseDynamicVars(TP, NP, CP, SS);

% Initialise the input models (if any)
if isfield(NP, 'Input')
  [InputModelArr] = setupInputDynamicVars(TP, NP, SS);
else
  InputModelArr = [];
end

disp('synweightds')

% Prepare synapses and synaptic weights. 
[synapsesArrSim, weightArr] = prepareSynapsesAndWeights(TP,CP,SS,connections);
disp('rec vars')
% Initialise the recording variables
[RS, RecordingVars, lineSourceModCell] = ...
  setupRecordingVars(TP, NP, SS, RS, NeuronIDMap, electrodes, weightArr,synapsesArrSim);

%It will assign the values passed to it to the v_ext field of the neuron.
if isfield(TP, 'StimulationField')
    if SS.parallelSim
        compartments = TP.compartmentlocations;
        spmd
                subsetInLab = find(SS.neuronInLab==labindex());
            NeuronModelArr = get_compartment_midpoints(TP,NeuronModelArr, SS,compartments);
            if isa(TP.StimulationField,'pde.TimeDependentResults')
                 for iGroup = 1:length(NeuronModelArr)
                     for iStimTime = 1:size(TP.StimulationField.NodalSolution,2)
                        paraStimParam(iGroup).V_ext_mat(:,:,iStimTime) = get_V_ext(NeuronModelArr{iGroup}.midpoints, TP.StimulationField,iStimTime);
                     end
                     setVext(NeuronModelArr{iGroup},paraStimParam(iGroup).V_ext_mat(:,:,1));
                 end
                 nsaves = 0;
            else
                for iGroup = 1:length(NeuronModelArr)
                    setVext(NeuronModelArr{iGroup},get_V_ext(NeuronModelArr{iGroup}.midpoints, TP.StimulationField,1));
                end
                if isfield(TP,'tRNS')
                    setVext(NeuronModelArr{iGroup},NeuronModelArr{iGroup}.v_ext*TP.tRNS);
                end
            end
        end
    else
        NeuronModelArr = get_compartment_midpoints(TP,NeuronModelArr, SS, TP.compartmentlocations);
        if isa(TP.StimulationField,'pde.TimeDependentResults')  
            for iGroup = 1:length(NeuronModelArr)
                for iStimTime = 1:size(TP.StimulationField.NodalSolution,2)
                    NP(iGroup).V_ext_mat(:,:,iStimTime) = get_V_ext(NeuronModelArr{iGroup}.midpoints, TP.StimulationField,iStimTime);
                end                
                setVext(NeuronModelArr{iGroup},NP(iGroup).V_ext_mat(:,:,1));
            end
        else
            for iGroup = 1:length(NeuronModelArr)
                setVext(NeuronModelArr{iGroup},get_V_ext(NeuronModelArr{iGroup}.midpoints, TP.StimulationField,1));
            end
        end
    end

end


VERTEX.outputDirectory = RS.saveDir;

nIntSize = 'uint32';
tIntSize = 'uint16';

iterator.groupComparts = [NP.numCompartments];

iterator.numInGroup = diff(TP.groupBoundaryIDArr);
VERTEX.neuronInGroup = ...
    createGroupsFromBoundaries(TP.groupBoundaryIDArr);

if isfield(SS,'spikeLoad')
    S.spikeLoad = SS.spikeLoad;
else
    S.spikeLoad = false;
end

if S.spikeLoad
    inputDirectory = SS.spikeLoadDir;
    if ~strcmpi(inputDirectory(end), '/')
        inputDirectory = [inputDirectory '/'];
    end
    fName = sprintf('%sRecordings%d.mat', inputDirectory, numSaves);
    loadedSpikes = load(fName);
    iterator.dataFieldName = fields(loadedSpikes);
end

    iterator.recTimeCounter = 1;
    iterator.sampleStepCounter = 1;
    iterator.spikeRecCounter = 1;
    iterator.comCount = SS.minDelaySteps;
    iterator.numSaves = 1;
    iterator.bufferLength = SS.maxDelaySteps;
    iterator.nsaves = 0;
    iterator.weightsArrcount = 1;

% vars to keep track of spikes
S.spikes = zeros(TP.N * SS.minDelaySteps, 1, nIntSize);
S.spikeStep = zeros(TP.N * SS.minDelaySteps, 1, tIntSize);
S.spikeCount = zeros(1, 1, nIntSize);





iterator.stimcount = 1;
iterator.timeStimStep = 1; %NB: thee two weren't part of iterator in the multiregion code, 
% will need to adapt simulateMultiregional accordingly.

% simulation loop
%disp(['max: ' num2str(max(StimParams.activation))]);

stdp = SS.stdp;

if stdp
    disp('Using stdp, so calculating postsynaptic to presynaptic map');
    
    VERTEX.revSynArr = reverseSynArr(synArr);
    
    disp('Map calculated');
else
    VERTEX.revSynArr =[];
end

iterator.stdp=stdp;

VERTEX.CP=CP;
VERTEX.TP=TP;
VERTEX.NP=NP;
VERTEX.SS=SS;
VERTEX.RS=RS;
VERTEX.S=S;
VERTEX.iterator=iterator;
VERTEX.IDMap=NeuronIDMap;
VERTEX.NMA=NeuronModelArr;
VERTEX.SMA=SynapseModelArr;
VERTEX.IMA=InputModelArr;
VERTEX.RecVar = RecordingVars;
VERTEX.lineSourceModCell=lineSourceModCell;
VERTEX.synArr=synapsesArrSim;
VERTEX.wArr=weightArr;
VERTEX.synMap=synMapCell;
VERTEX.simStep = 1;

% [NeuronModel, SynModel, InModel, iterator,S,RecVar,wArr] = 
% simulateMultiregional(TP, NP, SS, RS, S, iterator, simStep, revSynArr, IDMap, ...
%    NeuronModel, SynModel, InModel, RecVar, neuronInGroup, 
%lineSourceModCell, synArr, wArr, synMap,rgn)

%    simulate(TP, NP, SS, RS, NeuronIDMap, NeuronModelArr, ...
%    SynapseModelArr, InputModelArr, RecordingVars, lineSourceModCell, ...
%    synapsesArrSim, weightArr, synMapCell);
end
