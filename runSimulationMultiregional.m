function[synapsesArrSim] =  runSimulationMultiregional(pS, connectionStacked, electrodeStacked,regionConnect)
%RUNSIMULATION Run the simulation given the model generated by initNetwork().
%   RUNSIMULATION(PARAMS, CONNECTIONS, ELECTRODES) runs the simulation
%   given the model generated by initNetwork(). PARAMS, CONNECTIONS and
%   ELECTRODES are the PARAMS, CONNECTIONS and ELECTRODES outputs from the
%   initNetwork() function. RUNSIMULATION automatically saves the simulation
%   results in the directory specified by the user in the recording
%   settings structure given to initNetwork().


% unstack the parameters for the different regions

ROI_N = length(pS);


% Create shorthand names for the parameter structures in params
% TP = params.TissueParams;
% NP = params.NeuronParams;
% CP = params.ConnectionParams;
% RS = params.RecordingSettings;
% SS = params.SimulationSettings;

% Get the directory to save files to (and create it if necessary)
outputDirectory = pS{1}.RecordingSettings.saveDir; %the saveDir should be the same for each region.
if ~strcmpi(outputDirectory(end), '/')
  outputDirectory = [outputDirectory '/'];
end
if exist(outputDirectory, 'dir') ~= 7
  mkdir(outputDirectory);
end

numSaves = 1;
nIntSize = 'uint32';
tIntSize = 'uint16';

% If loading spikes from a previous simulation, and spikeLoadDir is not
% specified in params.SimulationSettings, assume that we are loading spikes
% from the output directory

for rn=1:ROI_N %loop for region number
    
    pS{rn}.RecordingSettings.saveDir = outputDirectory;
    if isfield(pS{rn}.SimulationSettings,'spikeLoad')
        if pS{rn}.SimulationSettings.spikeLoad
            if ~isfield(pS{rn}.SimulationSettings, 'spikeLoadDir')
                inputDirectory = outputDirectory;
                pS{rn}.SimulationSettings.spikeLoadDir = inputDirectory;
            end
        end
    end
    
    
    %NP = NeuronParams;
    % Calculate passive neuron properties in correct units
    pS{rn}.NeuronParams = calculatePassiveProperties(pS{rn}.NeuronParams, pS{rn}.TissueParams);
    
    
    % If using pre-calculated spike times with the loadspiketimes neuron model,
    % check the stored spike times can be found, then load them and convert
    % into units of timeStep
    loadedSpikeTimeCell{rn} = cell(pS{rn}.TissueParams.numGroups, 1);
    for iGroup = 1:pS{rn}.TissueParams.numGroups
        if strcmpi(pS{rn}.NeuronParams(iGroup).neuronModel, 'loadspiketimes')
            spkfile = pS{rn}.NeuronParams(iGroup).spikeTimeFile; % check spikeTimeDir is a field
            if exist(spkfile,'file') ~= 2
                errMsg = ['The specified spike time file for neuron group ' ...
                    num2str(iGroup) ' does not exist.'];
                error('vertex:runSimulation:spikeTimeDirError', errMsg);
            else
                loadedSpikeTimes = load(spkfile);
                fName = fields(loadedSpikeTimes);
                loadedSpikeTimeCell{iGroup} = loadedSpikeTimes.(fName{1});
                for ii = 1:length(loadedSpikeTimeCell{iGroup})
                    loadedSpikeTimeCell{iGroup}{ii} = ...
                        sort(round(loadedSpikeTimeCell{iGroup}{ii} ./ pS{rn}.SimulationSettings.timeStep));
                end
            end
        end
    end
    
    % Setup the neuron ID mapping for routing spikes, saving variables etc.
    [NeuronIDMap{rn}] = setupNeuronIDMapping(pS{rn}.TissueParams, pS{rn}.SimulationSettings);
    
    % Initialise the neuron models
    [NeuronModelArr{rn}] = ...
        setupNeuronDynamicVars(pS{rn}.TissueParams, pS{rn}.NeuronParams, pS{rn}.SimulationSettings, NeuronIDMap{rn}, loadedSpikeTimeCell);
    
    % Initialise the synapse models
    [SynapseModelArr{rn}, synMapCell{rn}] = setupSynapseDynamicVars(pS{rn}.TissueParams, pS{rn}.NeuronParams, pS{rn}.ConnectionParams, pS{rn}.SimulationSettings,connectionStacked{rn});
    
    % Initialise the input models (if any)
    if isfield(pS{rn}.NeuronParams, 'Input')
        [InputModelArr{rn}] = setupInputDynamicVars(pS{rn}.TissueParams, pS{rn}.NeuronParams, pS{rn}.SimulationSettings);
    else
        InputModelArr{rn} = [];
    end
    
    
    
    % Prepare synapses and synaptic weights.
    [synapsesArrSim{rn}, weightArr{rn}] = prepareSynapsesAndWeights(pS{rn}.TissueParams,pS{rn}.ConnectionParams,pS{rn}.SimulationSettings,connectionStacked{rn});
    
    % Initialise the recording variables
    [pS{rn}.RecordingSettings, RecVar{rn}, lineSourceModCell{rn}] = ...
        setupRecordingVars(pS{rn}.TissueParams, pS{rn}.NeuronParams, pS{rn}.SimulationSettings, pS{rn}.RecordingSettings, NeuronIDMap{rn}, electrodeStacked{rn}, weightArr{rn},synapsesArrSim);
    
    %% Setting the stimulation field v_ext for each neuron compartment
    %Get_V_ext returns the extracellular potential specified by
    %TP.StimulationsField at each of the compartment midpoints.
    %setVext is a function attached to the NeuronModel object.
    
    %It will assign the values passed to it to the v_ext field of the neuron.
    if isfield(pS{rn}.TissueParams, 'StimulationField')
        if pS{rn}.SimulationSettings.parallelSim
            compartments = pS{rn}.TissueParams.compartmentlocations;
            spmd
                subsetInLab = find(pS{rn}.SimulationSettings.neuronInLab==labindex());
                NeuronModelArr{rn} = get_compartment_midpoints(pS{rn}.TissueParams,NeuronModelArr{rn}, pS{rn}.SimulationSettings,compartments{rn});
                if isa(pS{rn}.TissueParams.StimulationField,'pde.TimeDependentResults')
                    for iGroup = 1:length(NeuronModelArr{rn})
                        for iStimTime = 1:size(pS{rn}.TissueParams.StimulationField.NodalSolution,2)
                            paraStimParam(iGroup).V_ext_mat(:,:,iStimTime) = get_V_ext(NeuronModelArr{rn}{iGroup}.midpoints, pS{rn}.TissueParams.StimulationField,iStimTime);
                        end
                        setVext(NeuronModelArr{rn}{iGroup},paraStimParam(iGroup).V_ext_mat(:,:,1));
                    end
                    nsaves = 0;
                else
                    for iGroup = 1:length(NeuronModelArr{rn})
                        setVext(NeuronModelArr{rn}{iGroup},get_V_ext(NeuronModelArr{rn}{iGroup}.midpoints, pS{rn}.TissueParams.StimulationField,1));
                    end
                    if isfield(pS{rn}.TissueParams,'tRNS')
                        setVext(NeuronModelArr{Rn}{iGroup},NeuronModelArr{rn}{iGroup}.v_ext*pS{rn}.TissueParams.tRNS);
                    end
                end
            end
        else
            NeuronModelArr{rn} = get_compartment_midpoints(pS{rn}.TissueParams,NeuronModelArr{rn}, pS{rn}.SimulationSettings, pS{rn}.TissueParams.compartmentlocations);
            if isa(pS{rn}.TissueParams.StimulationField,'pde.TimeDependentResults')
                for iGroup = 1:length(NeuronModelArr{rn})
                    for iStimTime = 1:size(pS{rn}.TissueParams.StimulationField.NodalSolution,2)
                        pS{rn}.NeuronParams(iGroup).V_ext_mat(:,:,iStimTime) = get_V_ext(NeuronModelArr{rn}{iGroup}.midpoints, pS{rn}.TissueParams.StimulationField,iStimTime);
                    end
                    setVext(NeuronModelArr{rn}{iGroup},pS{rn}.NeuronParams(iGroup).V_ext_mat(:,:,1));
                end
            else
                for iGroup = 1:length(NeuronModelArr{rn})
                    setVext(NeuronModelArr{rn}{iGroup},get_V_ext(NeuronModelArr{rn}{iGroup}.midpoints, pS{rn}.TissueParams.StimulationField,1));
                end
            end
        end
        
    end
    
   %% spike loading nad stdp
    
    if isfield(pS{rn}.SimulationSettings,'spikeLoad')
        S{rn}.spikeLoad = pS{rn}.SimulationSettings.spikeLoad;
    else
        S{rn}.spikeLoad = false;
    end
    
    if S{rn}.spikeLoad
        inputDirectory = pS{rn}.SimulationSettings.spikeLoadDir;
        if ~strcmpi(inputDirectory(end), '/')
            inputDirectory = [inputDirectory '/'];
        end
        fName = sprintf('%sRecordings%d.mat', inputDirectory, numSaves);
        loadedSpikes = load(fName);
        dataFieldName{rn} = fields(loadedSpikes);
    else
        loadedSpikes = [];
        
    end
    
    S{rn}.spikes = zeros(pS{rn}.TissueParams.N * pS{rn}.SimulationSettings.minDelaySteps, 1, nIntSize);
    S{rn}.spikeStep = zeros(pS{rn}.TissueParams.N * pS{rn}.SimulationSettings.minDelaySteps, 1, tIntSize);
    S{rn}.spikeCount = zeros(1, 1, nIntSize);
    
    iterator(rn).groupComparts = [pS{rn}.NeuronParams.numCompartments];
    
    iterator(rn).numInGroup = diff(pS{rn}.TissueParams.groupBoundaryIDArr);
    neuronInGroup{rn} = ...
        createGroupsFromBoundaries(pS{rn}.TissueParams.groupBoundaryIDArr);
    
    %disp(['max: ' num2str(max(StimParams.activation))]);
    iterator(rn).stdp = false;
    for iPostGroup = 1:length(SynapseModelArr{rn}(:,1))
        for iSpkSynGroup = 1:length(SynapseModelArr{rn}(iPostGroup,:))
            if isa(SynapseModelArr{rn}{iPostGroup, iSpkSynGroup}, 'SynapseModel_g_stdp')
                iterator(rn).stdp = true;
            end
        end
    end
    
    if iterator(rn).stdp
        disp('Using stdp, so calculating postsynaptic to presynaptic map');
        
        posttoprearr{rn} = reverseSynArr(synapsesArrSim{rn});
        
        disp('Map calculated');
    else
        posttoprearr{rn} = [];
    end
    
    
    % vars to keep track of where we are in recording buffers:
    iterator(rn).recTimeCounter = 1;
    iterator(rn).sampleStepCounter = 1;
    iterator(rn).spikeRecCounter = 1;
    iterator(rn).comCount = pS{rn}.SimulationSettings.minDelaySteps;
    iterator(rn).numSaves = numSaves;
    iterator(rn).loadedSpikes = loadedSpikes;
    iterator(rn).bufferLength = pS{rn}.SimulationSettings.maxDelaySteps;
    iterator(rn).nsaves = 0;
    
end
clear rn

outputDirectory = pS{1}.RecordingSettings.saveDir;

stimcount = 1;
timeStimStep = 1;


simulationSteps = round(pS{1}.SimulationSettings.simulationTime / pS{1}.SimulationSettings.timeStep);




%% Simulation loop


for simStep = 1:simulationSteps
    
    for rgn = 1:ROI_N
        
        % first establish the stimulation field, if there is one, as this is dependent on the current time value.
        if isfield(pS{rgn}.TissueParams, 'StimulationField')
            current_time = simStep * pS{rgn}.SimulationSettings.timeStep;
            
            if current_time > pS{rgn}.TissueParams.StimulationOn(stimcount) && current_time < pS{rgn}.TissueParams.StimulationOff(stimcount)
                for iGroup = 1:pS{rgn}.TissueParams.numGroups
                    if  ~NeuronModelArr{rgn}{iGroup}.incorporate_vext
                        stimulationOn(NeuronModelArr{rgn}{iGroup});
                        disp('stimulation on')
                    end
                    % For time varying stimulation, step through the time
                    % dimension of the vext matrix for each simStep where
                    % stimulation is active. The vext matrix should have
                    % been previously interpolated in runSimulation.
                    if isa(pS{rgn}.TissueParams.StimulationField, 'pde.TimeDependentResults')
                        setVext(NeuronModelArr{rgn}{iGroup},pS{rgn}.NeuronParams(iGroup).V_ext_mat(:,:,timeStimStep));
                    elseif isfield(pS{rgn}.TissueParams, 'tRNS')
                        setVext(NeuronModelArr{rgn}{iGroup},NeuronModelArr{rgn}{iGroup}.v_ext*pS{rgn}.TissueParams.tRNS);
                    end
                    
                end
                if isfield(pS{rgn}.TissueParams, 'tRNS')
                    pS{rgn}.TissueParams.tRNS = wgn(1,1,0); % generate a new random number for tRNS.
                end
                timeStimStep = timeStimStep+1;
                % reset timeStimStep if it gets passed the length of the
                % time dimension in the stimulation field, this will loop
                % back to the beginning of the time varying stimulation.
                if timeStimStep > size(pS{rgn}.TissueParams.StimulationField.NodalSolution,2)
                    timeStimStep = 1;
                end
            elseif current_time > pS{rgn}.TissueParams.StimulationOff(stimcount)
                for iGroup = 1:pS{rgn}.TissueParams.numGroups
                    if  NeuronModelArr{rgn}{iGroup}.incorporate_vext
                        stimulationOn(NeuronModelArr{rgn}{iGroup});
                        disp('stimulation off')
                        stimulationOff(NeuronModelArr{rgn}{iGroup});
                    end
                    if stimcount < length(pS{rgn}.TissueParams.StimulationOn)
                        stimcount = stimcount+1;
                    end
                end
            end
        end
        
        % now simulate for the current time step, dependent on parallel or
        % serial mode
        
        if pS{1}.SimulationSettings.parallelSim
            % IF IN PARALLEL MODE:
            
            if isfield(pS{rgn}.TissueParams, 'StimulationField') && isa(pS{rgn}.TissueParams.StimulationField,'pde.TimeDependentResults')
                simulateParallelMultiregion(pS{rgn}.TissueParams, pS{rgn}.NeuronParams, pS{rgn}.SimulationSettings, pS{rgn}.RecordingSettings, NeuronIDMap{rgn}, NeuronModelArr{rgn}, ...
                    SynapseModelArr{rgn}, InputModelArr{rgn}, RecVar{rgn}, lineSourceModCell{rgn}, ...
                    synapsesArrSim{rgn}, weightArr{rgn}, synMapCell{rgn},paraStimParam{rgn});
            else
                simulateParallelMultiregion(pS{rgn}.TissueParams, pS{rgn}.NeuronParams, pS{rgn}.SimulationSettings, pS{rgn}.RecordingSettings, NeuronIDMap{rgn}, NeuronModelArr{rgn}, ...
                    SynapseModelArr{rgn}, InputModelArr{rgn}, RecordingVars{rgn}, lineSourceModCell{rgn}, ...
                    synapsesArrSim, weightArr, synMapCell);
            end
            
            
        else
            % IF IN SERIAL MODE:
            
            [NeuronModelArr{rgn}, SynapseModelArr{rgn}, InputModelArr{rgn}, iterator(rgn)] = simulateMultiregional(pS{rgn}.TissueParams, pS{rgn}.NeuronParams, pS{rgn}.SimulationSettings, pS{rgn}.RecordingSettings, S{rgn}, iterator(rgn), simStep, posttoprearr{rgn}, NeuronIDMap{rgn}, NeuronModelArr{rgn}, ...
                SynapseModelArr{rgn}, InputModelArr{rgn}, RecVar{rgn}, neuronInGroup{rgn}, lineSourceModCell{rgn}, ...
                synapsesArrSim{rgn}, weightArr{rgn}, synMapCell{rgn});
            
        end
        %now need to check for incoming spikes for the next region and
        %feed these in by modifying the S parameter? To make this
        %extendible I will need some kind of matrix to hold which
        %regions connect to which other regions, and then only send
        %spikes to the recieving regions.
        
        if sum(regionConnect(rgn,:)>1) %check if the current region has an outbound connection
            %update the spikes by putting these into the recieving region.
            
        end
        
        %update rates for the connections from rgn to all other
        %regions
        
        
    end
    
end



if isfield(pS{1}.RecordingSettings,'LFPoffline') && pS{1}.RecordingSettings.LFPoffline
    save(outputDirectory, 'LineSourceConsts.mat', lineSourceModCell);
end


% Store the parameters in the same folder, so we can reference them later
% during analysis (used by loadResults, as well as useful for tracking
% simulations). You may want to copy these lines to store each parameter
% set after every time you call simulate()/simulateParallel().
parameterCell = {pS,SynapseModelArr};
fname = [outputDirectory 'parameters.mat'];
save(fname, 'parameterCell','-v7.3'); % saving in version 7.3 to avoid errors from large files.